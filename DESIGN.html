

<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mp-units - Design Overview &mdash; mp-units 0.5.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> mp-units
          

          
          </a>

          
            
            
              <div class="version">
                0.5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="quick_start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="framework.html">Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="scenarios.html">Scenarios</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="reference/concepts.html">Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference/types.html">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference/functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference/functions.html#metafunctions">Metafunctions</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference/systems.html">Systems</a></li>
</ul>
<p class="caption"><span class="caption-text">Appendix:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHANGELOG.html">Release notes</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">mp-units</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><code class="docutils literal notranslate"><span class="pre">mp-units</span></code> - Design Overview</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/DESIGN.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mp-units-design-overview">
<h1><code class="docutils literal notranslate"><span class="pre">mp-units</span></code> - Design Overview<a class="headerlink" href="#mp-units-design-overview" title="Permalink to this headline">¶</a></h1>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">mp-units</span></code> is a compile-time enabled Modern C++ library that provides compile-time dimensional
analysis and unit/quantity manipulation. The basic idea and design heavily bases on
<code class="docutils literal notranslate"><span class="pre">std::chrono::duration</span></code> and extends it to work properly with many dimensions.</p>
<p>Here is a small example of possible operations:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// simple numeric operations</span>
<span class="k">static_assert</span><span class="p">(</span><span class="mi">10</span><span class="n">q_km</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">5</span><span class="n">q_km</span><span class="p">);</span>

<span class="c1">// unit conversions</span>
<span class="k">static_assert</span><span class="p">(</span><span class="mi">1</span><span class="n">q_h</span> <span class="o">==</span> <span class="mi">3600</span><span class="n">q_s</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="mi">1</span><span class="n">q_km</span> <span class="o">+</span> <span class="mi">1</span><span class="n">q_m</span> <span class="o">==</span> <span class="mi">1001</span><span class="n">q_m</span><span class="p">);</span>

<span class="c1">// dimension conversions</span>
<span class="k">static_assert</span><span class="p">(</span><span class="mi">1</span><span class="n">q_km</span> <span class="o">/</span> <span class="mi">1</span><span class="n">q_s</span> <span class="o">==</span> <span class="mi">1000</span><span class="n">q_m_per_s</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="mi">2</span><span class="n">q_km_per_h</span> <span class="o">*</span> <span class="mi">2</span><span class="n">q_h</span> <span class="o">==</span> <span class="mi">4</span><span class="n">q_km</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="mi">2</span><span class="n">q_km</span> <span class="o">/</span> <span class="mi">2</span><span class="n">q_km_per_h</span> <span class="o">==</span> <span class="mi">1</span><span class="n">q_h</span><span class="p">);</span>

<span class="k">static_assert</span><span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="mi">1</span><span class="n">q_s</span> <span class="o">==</span> <span class="mi">1</span><span class="n">q_kHz</span><span class="p">);</span>

<span class="k">static_assert</span><span class="p">(</span><span class="mi">10</span><span class="n">q_km</span> <span class="o">/</span> <span class="mi">5</span><span class="n">q_km</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="approach">
<h2>Approach<a class="headerlink" href="#approach" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Safety and performance</p>
<ul class="simple">
<li><p>strong types</p></li>
<li><p>compile-time safety</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> all the things</p></li>
<li><p>as fast or even faster than when working with fundamental types</p></li>
</ul>
</li>
<li><p>The best possible user experience</p>
<ul class="simple">
<li><p>compiler errors</p></li>
<li><p>debugging</p></li>
</ul>
</li>
<li><p>No macros in the user interface</p></li>
<li><p>Easy extensibility</p></li>
<li><p>No external dependencies</p></li>
<li><p>Possibility to be standardized as a freestanding part of the C++ Standard Library</p></li>
</ol>
</div>
<div class="section" id="basic-concepts">
<h2>Basic Concepts<a class="headerlink" href="#basic-concepts" title="Permalink to this headline">¶</a></h2>
<p>The most important concepts in the library are <code class="docutils literal notranslate"><span class="pre">Unit</span></code>, <code class="docutils literal notranslate"><span class="pre">Dimension</span></code>, and <code class="docutils literal notranslate"><span class="pre">Quantity</span></code>:</p>
<p><img alt="Design UML" src="_images/concepts.png" /></p>
<p><code class="docutils literal notranslate"><span class="pre">Unit</span></code> is a basic building block of the library. Every dimension works with a concrete
hierarchy of units. Such hierarchy defines a reference unit and often a few scaled versions of
it.</p>
<p><code class="docutils literal notranslate"><span class="pre">Dimension</span></code> concept matches a dimension of either a base or derived quantity. <code class="docutils literal notranslate"><span class="pre">base_dimension</span></code>
is instantiated with a unique symbol identifier and a base unit. <code class="docutils literal notranslate"><span class="pre">derived_unit</span></code> is a list of
exponents of either base or other derived dimensions.</p>
<p><code class="docutils literal notranslate"><span class="pre">Quantity</span></code> is a concrete amount of a unit for a specified dimension with a specific
representation.</p>
</div>
<div class="section" id="unit">
<h2><code class="docutils literal notranslate"><span class="pre">Unit</span></code><a class="headerlink" href="#unit" title="Permalink to this headline">¶</a></h2>
<p>All units are represented in the framework by a <code class="docutils literal notranslate"><span class="pre">scaled_unit</span></code> class template:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">UnitRatio</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">scaled_unit</span> <span class="p">:</span> <span class="n">downcast_base</span><span class="o">&lt;</span><span class="n">scaled_unit</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">ratio</span> <span class="o">=</span> <span class="n">R</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">U</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">UnitRatio</span> <span class="o">=</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">R</span><span class="o">::</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">R</span><span class="o">::</span><span class="n">den</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// double negatives not allowed</span>
</pre></div>
</div>
<p>and <code class="docutils literal notranslate"><span class="pre">Ratio</span></code> is satisfied by any instantiation of <code class="docutils literal notranslate"><span class="pre">units::ratio&lt;Num,</span> <span class="pre">Den,</span> <span class="pre">Exp&gt;</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">scaled_unit</span></code> type is a framework’s private type and the user should never instantiate it directly.
The public user interface to create units consists of:</p>
<p><img alt="Units UML" src="_images/units.png" /></p>
<p>All below class templates indirectly derive from a <code class="docutils literal notranslate"><span class="pre">scaled_unit</span></code> class template and satisfy a
<code class="docutils literal notranslate"><span class="pre">Unit</span></code> concept:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">unit</span></code></p>
<ul>
<li><p>Defines a new unnamed, in most cases coherent derived unit of a specific derived
dimension and it should be passed in this dimension’s definition.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">named_unit</span></code></p>
<ul>
<li><p>Defines a named, in most cases base or coherent unit that is then passed to a dimension’s
definition.</p></li>
<li><p>A named unit may be used by other units defined with the prefix of the same type, unless
<code class="docutils literal notranslate"><span class="pre">no_prefix</span></code> is provided for <code class="docutils literal notranslate"><span class="pre">PrefixType</span></code> template parameter (in such a case it is impossible
to define a prefixed unit based on this one).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">named_scaled_unit</span></code></p>
<ul>
<li><p>Defines a new named unit that is a scaled version of another unit.</p></li>
<li><p>Such unit can be used by other units defined with the prefix of the same type, unless
<code class="docutils literal notranslate"><span class="pre">no_prefix</span></code> is provided for <code class="docutils literal notranslate"><span class="pre">PrefixType</span></code> template parameter (in such a case it is impossible
to define a prefixed unit based on this one).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">prefixed_unit</span></code></p>
<ul>
<li><p>Defines a new unit that is a scaled version of another unit by the provided prefix.</p></li>
<li><p>It is only possible to create such a unit if the given prefix type matches the one defined
in a reference unit.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">deduced_unit</span></code></p>
<ul>
<li><p>Defines a new unit with a deduced ratio and symbol based on the recipe from the provided
derived dimension.</p></li>
<li><p>The number and order of provided units should match the recipe of the derived dimension.</p></li>
<li><p>All of the units provided should also be a named ones so it is possible to create a deduced
symbol text.</p></li>
</ul>
</li>
</ul>
<p>Some of the above types depend on <code class="docutils literal notranslate"><span class="pre">PrefixType</span></code> and <code class="docutils literal notranslate"><span class="pre">no_prefix</span></code>. <code class="docutils literal notranslate"><span class="pre">PrefixType</span></code> is a concept that
is defined as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">PrefixType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">derived_from</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">prefix_type</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">prefix_type</span></code> is just an empty tag type used to identify the beginning of prefix types
hierarchy and <code class="docutils literal notranslate"><span class="pre">no_prefix</span></code> is one of its children:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">prefix_type</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">no_prefix</span> <span class="p">:</span> <span class="n">prefix_type</span> <span class="p">{};</span>
</pre></div>
</div>
<p>Concrete prefix derives from a <code class="docutils literal notranslate"><span class="pre">prefix</span></code> class template:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Child</span><span class="p">,</span> <span class="n">PrefixType</span> <span class="n">PT</span><span class="p">,</span> <span class="n">basic_fixed_string</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Ratio</span> <span class="n">R</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">PT</span><span class="p">,</span> <span class="n">no_prefix</span><span class="o">&gt;</span><span class="p">)</span>
<span class="k">struct</span> <span class="n">prefix</span><span class="p">;</span>
</pre></div>
</div>
<p>You could notice that both units and above <code class="docutils literal notranslate"><span class="pre">prefix</span></code> class template take <code class="docutils literal notranslate"><span class="pre">Child</span></code> as a first
template parameter. <code class="docutils literal notranslate"><span class="pre">mp-units</span></code> library heavily relies on CRTP (Curiously Recurring Template
Parameter) idiom to provide the best user experience in terms of readability of compilation
errors and during debugging. It is possible thanks to the downcasting facility described later
in the design documentation.</p>
<p>Coming back to units, here are a few examples of unit definitions:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">units</span><span class="o">::</span><span class="n">si</span> <span class="p">{</span>

<span class="c1">// prefixes</span>
<span class="k">struct</span> <span class="nl">prefix</span> <span class="p">:</span> <span class="n">prefix_type</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">centi</span> <span class="p">:</span> <span class="n">units</span><span class="o">::</span><span class="n">prefix</span><span class="o">&lt;</span><span class="n">centi</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">&gt;&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">kilo</span> <span class="p">:</span> <span class="n">units</span><span class="o">::</span><span class="n">prefix</span><span class="o">&lt;</span><span class="n">kilo</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="s">&quot;k&quot;</span><span class="p">,</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&gt;</span> <span class="p">{};</span>

<span class="c1">// length</span>
<span class="k">struct</span> <span class="nl">metre</span> <span class="p">:</span> <span class="n">named_unit</span><span class="o">&lt;</span><span class="n">metre</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">centimetre</span> <span class="p">:</span> <span class="n">prefixed_unit</span><span class="o">&lt;</span><span class="n">centimetre</span><span class="p">,</span> <span class="n">centi</span><span class="p">,</span> <span class="n">metre</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">kilometre</span> <span class="p">:</span> <span class="n">prefixed_unit</span><span class="o">&lt;</span><span class="n">kilometre</span><span class="p">,</span> <span class="n">kilo</span><span class="p">,</span> <span class="n">metre</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="c1">// time</span>
<span class="k">struct</span> <span class="nl">second</span> <span class="p">:</span> <span class="n">named_unit</span><span class="o">&lt;</span><span class="n">second</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">hour</span> <span class="p">:</span> <span class="n">named_scaled_unit</span><span class="o">&lt;</span><span class="n">hour</span><span class="p">,</span> <span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="n">no_prefix</span><span class="p">,</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">3600</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">second</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="c1">// velocity</span>
<span class="k">struct</span> <span class="nl">metre_per_second</span> <span class="p">:</span> <span class="n">unit</span><span class="o">&lt;</span><span class="n">metre_per_second</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">kilometre_per_hour</span> <span class="p">:</span> <span class="n">deduced_unit</span><span class="o">&lt;</span><span class="n">kilometre_per_hour</span><span class="p">,</span> <span class="n">dim_velocity</span><span class="p">,</span> <span class="n">kilometre</span><span class="p">,</span> <span class="n">hour</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="p">}</span>

<span class="k">namespace</span> <span class="n">units</span><span class="o">::</span><span class="n">us</span> <span class="p">{</span>

<span class="c1">// length</span>
<span class="k">struct</span> <span class="nl">yard</span> <span class="p">:</span> <span class="n">named_scaled_unit</span><span class="o">&lt;</span><span class="n">yard</span><span class="p">,</span> <span class="s">&quot;yd&quot;</span><span class="p">,</span> <span class="n">no_prefix</span><span class="p">,</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">9&#39;144</span><span class="p">,</span> <span class="mi">10&#39;000</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">si</span><span class="o">::</span><span class="n">metre</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">mile</span> <span class="p">:</span> <span class="n">named_scaled_unit</span><span class="o">&lt;</span><span class="n">mile</span><span class="p">,</span> <span class="s">&quot;mi&quot;</span><span class="p">,</span> <span class="n">no_prefix</span><span class="p">,</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1&#39;760</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">yard</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="c1">// velocity</span>
<span class="k">struct</span> <span class="nl">mile_per_hour</span> <span class="p">:</span> <span class="n">deduced_unit</span><span class="o">&lt;</span><span class="n">mile_per_hour</span><span class="p">,</span> <span class="n">si</span><span class="o">::</span><span class="n">dim_velocity</span><span class="p">,</span> <span class="n">mile</span><span class="p">,</span> <span class="n">si</span><span class="o">::</span><span class="n">hour</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="p">}</span>
</pre></div>
</div>
<p>Please note that thanks to C++20 features we are able to provide all information about the unit
(including text output) in a single line of its type definition. There is no need to specialize
additional type traits or use preprocessor macros.</p>
</div>
<div class="section" id="dimension">
<h2><code class="docutils literal notranslate"><span class="pre">Dimension</span></code><a class="headerlink" href="#dimension" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Dimension</span></code> is either a <code class="docutils literal notranslate"><span class="pre">BaseDimension</span></code> or a <code class="docutils literal notranslate"><span class="pre">DerivedDimension</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">Dimension</span> <span class="o">=</span> <span class="n">BaseDimension</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n">DerivedDimension</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="basedimension">
<h3><code class="docutils literal notranslate"><span class="pre">BaseDimension</span></code><a class="headerlink" href="#basedimension" title="Permalink to this headline">¶</a></h3>
<p>According to ISO 80000 a base quantity is a quantity in a conventionally chosen subset of a
given system of quantities, where no quantity in the subset can be expressed in terms of the
other quantities within that subset. They are referred to as being mutually independent since a
base quantity cannot be expressed as a product of powers of the other base quantities. Base unit
is a measurement unit that is adopted by convention for a base quantity in a specific system of
units.</p>
<p><code class="docutils literal notranslate"><span class="pre">base_dimension</span></code> represents a dimension of a base quantity and is identified with a pair of
an unique compile-time text describing the dimension symbol and a base unit adopted for this
dimension:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">basic_fixed_string</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Unit</span> <span class="n">U</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="n">U</span><span class="o">::</span><span class="n">is_named</span>
<span class="k">struct</span> <span class="n">base_dimension</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">base_unit</span> <span class="o">=</span> <span class="n">U</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Pair of symbol and unit template parameters form an unique identifier of the base dimension.
These identifiers provide total ordering of exponents of base dimensions in a derived dimension.</p>
<p>The SI physical units system defines 7 base dimensions:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">units</span><span class="o">::</span><span class="n">si</span> <span class="p">{</span>

<span class="k">struct</span> <span class="nl">dim_length</span> <span class="p">:</span> <span class="n">base_dimension</span><span class="o">&lt;</span><span class="s">&quot;L&quot;</span><span class="p">,</span> <span class="n">metre</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">dim_mass</span> <span class="p">:</span> <span class="n">base_dimension</span><span class="o">&lt;</span><span class="s">&quot;M&quot;</span><span class="p">,</span> <span class="n">kilogram</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">dim_time</span> <span class="p">:</span> <span class="n">base_dimension</span><span class="o">&lt;</span><span class="s">&quot;T&quot;</span><span class="p">,</span> <span class="n">second</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">dim_electric_current</span> <span class="p">:</span> <span class="n">base_dimension</span><span class="o">&lt;</span><span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="n">ampere</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">dim_thermodynamic_temperature</span> <span class="p">:</span> <span class="n">base_dimension</span><span class="o">&lt;</span><span class="s">&quot;Θ&quot;</span><span class="p">,</span> <span class="n">kelvin</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">dim_substance</span> <span class="p">:</span> <span class="n">base_dimension</span><span class="o">&lt;</span><span class="s">&quot;N&quot;</span><span class="p">,</span> <span class="n">mole</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">dim_luminous_intensity</span> <span class="p">:</span> <span class="n">base_dimension</span><span class="o">&lt;</span><span class="s">&quot;J&quot;</span><span class="p">,</span> <span class="n">candela</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="p">}</span>
</pre></div>
</div>
<p>All other derived quantities of SI are composed from those.</p>
<p>There are two reasons why a <code class="docutils literal notranslate"><span class="pre">base_dimension</span></code> gets a unit as its template parameter. First, the
base unit is needed for the text output of unnamed derived units. Second, there is more than
one system of physical units. For example CGS definitions look as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">units</span><span class="o">::</span><span class="n">cgs</span> <span class="p">{</span>

<span class="k">using</span> <span class="n">si</span><span class="o">::</span><span class="n">centimetre</span><span class="p">;</span>
<span class="k">using</span> <span class="n">si</span><span class="o">::</span><span class="n">gram</span><span class="p">;</span>
<span class="k">using</span> <span class="n">si</span><span class="o">::</span><span class="n">second</span><span class="p">;</span>

<span class="k">struct</span> <span class="nl">dim_length</span> <span class="p">:</span> <span class="n">base_dimension</span><span class="o">&lt;</span><span class="s">&quot;L&quot;</span><span class="p">,</span> <span class="n">centimetre</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">dim_mass</span> <span class="p">:</span> <span class="n">base_dimension</span><span class="o">&lt;</span><span class="s">&quot;M&quot;</span><span class="p">,</span> <span class="n">gram</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">using</span> <span class="n">si</span><span class="o">::</span><span class="n">dim_time</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
<p>Equivalent base dimensions in different systems have the same symbol identifier and get units
from the same hierarchy (with the same reference in <code class="docutils literal notranslate"><span class="pre">scaled_unit</span></code>). Thanks to that we have
the ability to explicitly cast quantities of the same dimension from different systems or
even mix them in one <code class="docutils literal notranslate"><span class="pre">derived_dimension</span></code> definition.</p>
</div>
<div class="section" id="deriveddimension">
<h3><code class="docutils literal notranslate"><span class="pre">DerivedDimension</span></code><a class="headerlink" href="#deriveddimension" title="Permalink to this headline">¶</a></h3>
<p>According to ISO 80000 a derived quantity is a quantity, in a system of quantities, defined in
terms of the base quantities of that system. Dimension of such quantity is an expression of the
dependence of a quantity on the base quantities of a system of quantities as a product of
powers of factors corresponding to the base quantities, omitting any numerical factors. A power
of a factor is the factor raised to an exponent. Each factor is the dimension of a base
quantity.</p>
<p>A derived dimension used internally in a library framework is implemented as a type-list like
type that stores an ordered list of exponents of one or more base dimensions:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">Exponent</span> <span class="n">E</span><span class="p">,</span> <span class="n">Exponent</span><span class="p">...</span> <span class="n">ERest</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="p">(</span><span class="n">BaseDimension</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">::</span><span class="n">dimension</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="o">&amp;&amp;</span> <span class="n">BaseDimension</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ERest</span><span class="o">::</span><span class="n">dimension</span><span class="o">&gt;</span><span class="p">)</span>
<span class="k">struct</span> <span class="n">derived_dimension_base</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
<p>A derived dimension can be formed from multiple exponents (i.e. velocity is represented as
<code class="docutils literal notranslate"><span class="pre">exp&lt;L,</span> <span class="pre">1&gt;,</span> <span class="pre">exp&lt;T,</span> <span class="pre">-1&gt;</span></code>). It is also possible to form a derived dimension with only one exponent
(i.e. frequency is represented as just <code class="docutils literal notranslate"><span class="pre">exp&lt;T,</span> <span class="pre">-1&gt;</span></code>).</p>
<p>Exponents are implemented with <code class="docutils literal notranslate"><span class="pre">exp</span></code> class template that provides an information about a single
dimension and its (possibly fractional) exponent in a derived dimension.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">Dimension</span> <span class="n">Dim</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">Num</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">Den</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">exp</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">dimension</span> <span class="o">=</span> <span class="n">Dim</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">num</span> <span class="o">=</span> <span class="n">Num</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">intmax_t</span> <span class="n">den</span> <span class="o">=</span> <span class="n">Den</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In order to be able to perform computations on an arbitrary set of exponents,
<code class="docutils literal notranslate"><span class="pre">derived_dimension_base</span></code> class template have to obey the following rules:</p>
<ul class="simple">
<li><p>it contains only base dimensions in the list of exponents,</p></li>
<li><p>base dimensions are not repeated in a list (the exponent of each base dimension is provided
at most once),</p></li>
<li><p>exponents of base dimensions are consistently ordered,</p></li>
<li><p>in case the numerator of the exponent equals zero such base dimension is erased from the list.</p></li>
</ul>
<p>Above is needed for the framework to provide dimensional analysis. However, sometimes it is
useful to define derived units in terms of other derived units. To support this both a base
dimension and a derived dimension can be provided to <code class="docutils literal notranslate"><span class="pre">exp</span></code> class template.</p>
<p>As it was stated above <code class="docutils literal notranslate"><span class="pre">derived_dimension_base</span></code> is a private utility of the framework. In order
to define a new derived dimension the user has to instantiate the following class template:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Child</span><span class="p">,</span> <span class="n">Unit</span> <span class="n">U</span><span class="p">,</span> <span class="n">Exponent</span> <span class="n">E</span><span class="p">,</span> <span class="n">Exponent</span><span class="p">...</span> <span class="n">ERest</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">derived_dimension</span> <span class="p">:</span> <span class="n">downcast_child</span><span class="o">&lt;</span><span class="n">Child</span><span class="p">,</span> <span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">make_dimension</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">ERest</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">recipe</span> <span class="o">=</span> <span class="n">exp_list</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">ERest</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">coherent_unit</span> <span class="o">=</span> <span class="n">U</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">base_units_ratio</span> <span class="o">=</span> <span class="cm">/* see below */</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>There are a few important differences between <code class="docutils literal notranslate"><span class="pre">detail::derived_dimension_base</span></code> and
<code class="docutils literal notranslate"><span class="pre">derived_dimension</span></code>. First, the latter one gets the coherent unit of the derived dimension.</p>
<p>According to ISO 80000 a coherent unit is a unit that, for a given system of quantities and for
a chosen set of base units, is a product of powers of base units with no other proportionality
factor than one.</p>
<p>The other difference is that <code class="docutils literal notranslate"><span class="pre">derived_dimension</span></code> allows to provide other derived dimensions in
the list of its exponents. This is called a “recipe” of the dimension and among others is used
to print unnamed coherent units of this dimension.</p>
<p>In case a derived dimension appears on the list of exponents, such derived dimension will be
unpacked, sorted, and consolidated by a <code class="docutils literal notranslate"><span class="pre">detail::make_dimension</span></code> helper to form a valid list
of exponents of only base dimensions later provided to <code class="docutils literal notranslate"><span class="pre">detail::derived_dimension_base</span></code>.</p>
<p>Sometimes units of equivalent quantities in different systems of units do not share the same
reference so they cannot be easily converted to each other. An example can be a pressure for
which a coherent unit in SI is pascal and in CGS barye. Those two units are not directly
related with each other with some ratio. As they both are coherent units of their dimensions,
the ratio between them is directly determined by the ratios of base units defined in base
dimensions end their exponents in the derived dimension recipe. To provide interoperability of
such quantities of different systems <code class="docutils literal notranslate"><span class="pre">base_units_ratio</span></code> is being used. The result of the
division of two <code class="docutils literal notranslate"><span class="pre">base_units_ratio</span></code> of two quantities of equivalent dimensions in two different
systems gives a ratio between their coherent units. Alternatively, the user would always have to
directly define a barye in terms of pascal or vice versa.</p>
<p>Below are a few examples of derived dimension definitions:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">units</span><span class="o">::</span><span class="n">si</span> <span class="p">{</span>

<span class="k">struct</span> <span class="nl">dim_velocity</span> <span class="p">:</span> <span class="n">derived_dimension</span><span class="o">&lt;</span><span class="n">dim_velocity</span><span class="p">,</span> <span class="n">metre_per_second</span><span class="p">,</span>
                                        <span class="n">exp</span><span class="o">&lt;</span><span class="n">dim_length</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">exp</span><span class="o">&lt;</span><span class="n">dim_time</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">&gt;&gt;</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nl">dim_acceleration</span> <span class="p">:</span> <span class="n">derived_dimension</span><span class="o">&lt;</span><span class="n">dim_acceleration</span><span class="p">,</span> <span class="n">metre_per_second_sq</span><span class="p">,</span>
                                            <span class="n">exp</span><span class="o">&lt;</span><span class="n">dim_length</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">exp</span><span class="o">&lt;</span><span class="n">dim_time</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">&gt;&gt;</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nl">dim_force</span> <span class="p">:</span> <span class="n">derived_dimension</span><span class="o">&lt;</span><span class="n">dim_force</span><span class="p">,</span> <span class="n">newton</span><span class="p">,</span>
                                     <span class="n">exp</span><span class="o">&lt;</span><span class="n">dim_mass</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">exp</span><span class="o">&lt;</span><span class="n">dim_acceleration</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nl">dim_energy</span> <span class="p">:</span> <span class="n">derived_dimension</span><span class="o">&lt;</span><span class="n">dim_energy</span><span class="p">,</span> <span class="n">joule</span><span class="p">,</span>
                                      <span class="n">exp</span><span class="o">&lt;</span><span class="n">dim_force</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">exp</span><span class="o">&lt;</span><span class="n">dim_length</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nl">dim_power</span> <span class="p">:</span> <span class="n">derived_dimension</span><span class="o">&lt;</span><span class="n">dim_power</span><span class="p">,</span> <span class="n">watt</span><span class="p">,</span>
                                     <span class="n">exp</span><span class="o">&lt;</span><span class="n">dim_energy</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">exp</span><span class="o">&lt;</span><span class="n">dim_time</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">&gt;&gt;</span> <span class="p">{};</span>

<span class="p">}</span>
</pre></div>
</div>
<p>If as a result of dimensional computation the library framework will generate a derived
dimension that was not predefined by the user than the instance of
<code class="docutils literal notranslate"><span class="pre">unknown_dimension&lt;Exponent...&gt;</span></code>. The coherent unit of such an unknown dimension is
<code class="docutils literal notranslate"><span class="pre">scaled_unit&lt;ratio&lt;1&gt;,</span> <span class="pre">unknown_coherent_unit&gt;</span></code>.</p>
</div>
</div>
<div class="section" id="quantity">
<h2><code class="docutils literal notranslate"><span class="pre">Quantity</span></code><a class="headerlink" href="#quantity" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">quantity</span></code> is a class template that expresses the quantity/amount of a specific dimension
expressed in a specific unit of that dimension:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">Dimension</span> <span class="n">D</span><span class="p">,</span> <span class="n">UnitOf</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span> <span class="n">U</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">Rep</span> <span class="o">=</span> <span class="kt">double</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">quantity</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">quantity</span></code> provides a similar interface to <code class="docutils literal notranslate"><span class="pre">std::chrono::duration</span></code>. The difference is that it
uses <code class="docutils literal notranslate"><span class="pre">double</span></code> as a default representation and has a few additional member types and
functions as below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">Dimension</span> <span class="n">D</span><span class="p">,</span> <span class="n">UnitOf</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span> <span class="n">U</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">Rep</span> <span class="o">=</span> <span class="kt">double</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">quantity</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">using</span> <span class="n">dimension</span> <span class="o">=</span> <span class="n">D</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">U</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">rep</span> <span class="o">=</span> <span class="n">Rep</span><span class="p">;</span>

  <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">static</span> <span class="k">constexpr</span> <span class="n">quantity</span> <span class="n">one</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">D1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep2</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="n">detail</span><span class="o">::</span><span class="n">basic_arithmetic</span><span class="o">&lt;</span><span class="n">Rep1</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">equivalent_dim</span><span class="o">&lt;</span><span class="n">D1</span><span class="p">,</span> <span class="n">dim_invert</span><span class="o">&lt;</span><span class="n">D2</span><span class="o">&gt;&gt;</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">Scalar</span> <span class="k">auto</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D1</span><span class="p">,</span> <span class="n">U1</span><span class="p">,</span> <span class="n">Rep1</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D2</span><span class="p">,</span> <span class="n">U2</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">D1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep2</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="n">detail</span><span class="o">::</span><span class="n">basic_arithmetic</span><span class="o">&lt;</span><span class="n">Rep1</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">equivalent_dim</span><span class="o">&lt;</span><span class="n">D1</span><span class="p">,</span> <span class="n">dim_invert</span><span class="o">&lt;</span><span class="n">D2</span><span class="o">&gt;&gt;</span><span class="p">)</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">Quantity</span> <span class="k">auto</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D1</span><span class="p">,</span> <span class="n">U1</span><span class="p">,</span> <span class="n">Rep1</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span>
                                                <span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D2</span><span class="p">,</span> <span class="n">U2</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">Scalar</span> <span class="n">Value</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">magma</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">divided_by</span><span class="p">,</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Rep</span><span class="o">&gt;</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">Quantity</span> <span class="k">auto</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span>
                                                <span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Rep</span><span class="o">&gt;&amp;</span> <span class="n">q</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">D1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep2</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="n">detail</span><span class="o">::</span><span class="n">basic_arithmetic</span><span class="o">&lt;</span><span class="n">Rep1</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">equivalent_dim</span><span class="o">&lt;</span><span class="n">D1</span><span class="p">,</span> <span class="n">D2</span><span class="o">&gt;</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">Scalar</span> <span class="k">auto</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D1</span><span class="p">,</span> <span class="n">U1</span><span class="p">,</span> <span class="n">Rep1</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D2</span><span class="p">,</span> <span class="n">U2</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">D1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep2</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="n">detail</span><span class="o">::</span><span class="n">basic_arithmetic</span><span class="o">&lt;</span><span class="n">Rep1</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">equivalent_dim</span><span class="o">&lt;</span><span class="n">D1</span><span class="p">,</span> <span class="n">D2</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">Quantity</span> <span class="n">AUTO</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D1</span><span class="p">,</span> <span class="n">U1</span><span class="p">,</span> <span class="n">Rep1</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span>
                                                <span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D2</span><span class="p">,</span> <span class="n">U2</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</pre></div>
</div>
<p>Additional functions provide the support for operations that result in a different dimension
type than those of their arguments. <code class="docutils literal notranslate"><span class="pre">equivalent_dim</span></code> constraint requires two dimensions to be
either the same or have convertible units of base dimension (with the same reference unit).</p>
<p>Beside adding new elements a few other changes where applied compared to the <code class="docutils literal notranslate"><span class="pre">std::chrono::duration</span></code> class:</p>
<ol class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">duration</span></code> is using <code class="docutils literal notranslate"><span class="pre">std::common_type_t&lt;Rep1,</span> <span class="pre">Rep2&gt;</span></code> to find a common representation
for a calculation result. Such a design was reported as problematic by SG6 (numerics study group) members
as sometimes we want to provide a different type in case of multiplication and different in case of
division. <code class="docutils literal notranslate"><span class="pre">std::common_type</span></code> lacks that additional information. That is why <code class="docutils literal notranslate"><span class="pre">units::quantity</span></code> uses
the resulting type of a concrete operator operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">%</span></code> is constrained with <code class="docutils literal notranslate"><span class="pre">treat_as_floating_point</span></code> type trait to limit the types to integral
representations only. Also <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">%(Rep)</span></code> takes <code class="docutils literal notranslate"><span class="pre">Rep</span></code> as a template argument to limit implicit
conversions.</p></li>
</ol>
<p>To simplify writing efficient generic code quantities of each dimension have associated:</p>
<ol class="simple">
<li><p>Concept (i.e. <code class="docutils literal notranslate"><span class="pre">units::Length</span></code>) that matches a length dimension of any physical systems.</p></li>
<li><p>Per-system quantity alias (i.e. <code class="docutils literal notranslate"><span class="pre">units::si::length&lt;Unit,</span> <span class="pre">Rep&gt;</span></code> for
<code class="docutils literal notranslate"><span class="pre">units::quantity&lt;units::si::dim_length,</span> <span class="pre">Unit,</span> <span class="pre">Rep&gt;</span></code>).</p></li>
</ol>
<p>Also, to help instantiate quantities with compile-time known values every unit in the library
has an associated UDL. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">si</span><span class="o">::</span><span class="kr">inline</span> <span class="n">literals</span> <span class="p">{</span>

<span class="c1">// m</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">q_m</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="o">&lt;</span><span class="n">metre</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="p">}</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">q_m</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="o">&lt;</span><span class="n">metre</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// km</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">q_km</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="o">&lt;</span><span class="n">kilometre</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="p">}</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">q_km</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="o">&lt;</span><span class="n">kilometre</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="quantity-cast">
<h3><code class="docutils literal notranslate"><span class="pre">quantity_cast</span></code><a class="headerlink" href="#quantity-cast" title="Permalink to this headline">¶</a></h3>
<p>To explicitly force truncating conversions <code class="docutils literal notranslate"><span class="pre">quantity_cast</span></code> function is provided which is a direct
counterpart of <code class="docutils literal notranslate"><span class="pre">std::chrono::duration_cast</span></code>. As a template argument user can provide here either
a <code class="docutils literal notranslate"><span class="pre">quantity</span></code> type or only its template parameters (<code class="docutils literal notranslate"><span class="pre">Dimension</span></code>, <code class="docutils literal notranslate"><span class="pre">Unit</span></code>, or <code class="docutils literal notranslate"><span class="pre">Rep</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">Quantity</span> <span class="n">To</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="n">QuantityOf</span><span class="o">&lt;</span><span class="n">To</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">detail</span><span class="o">::</span><span class="n">basic_arithmetic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">To</span><span class="o">::</span><span class="n">rep</span><span class="p">,</span> <span class="n">Rep</span><span class="p">,</span> <span class="kt">intmax_t</span><span class="o">&gt;&gt;</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">quantity_cast</span><span class="p">(</span><span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Rep</span><span class="o">&gt;&amp;</span> <span class="n">q</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">Dimension</span> <span class="n">ToD</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="n">equivalent_dim</span><span class="o">&lt;</span><span class="n">ToD</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">quantity_cast</span><span class="p">(</span><span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Rep</span><span class="o">&gt;&amp;</span> <span class="n">q</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">Unit</span> <span class="n">ToU</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="n">UnitOf</span><span class="o">&lt;</span><span class="n">ToU</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">quantity_cast</span><span class="p">(</span><span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Rep</span><span class="o">&gt;&amp;</span> <span class="n">q</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">Scalar</span> <span class="n">ToRep</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Rep</span><span class="o">&gt;</span>
  <span class="k">requires</span> <span class="n">detail</span><span class="o">::</span><span class="n">basic_arithmetic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">ToRep</span><span class="p">,</span> <span class="n">Rep</span><span class="p">,</span> <span class="kt">intmax_t</span><span class="o">&gt;&gt;</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">quantity_cast</span><span class="p">(</span><span class="k">const</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">D</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Rep</span><span class="o">&gt;&amp;</span> <span class="n">q</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="text-output">
<h2>Text output<a class="headerlink" href="#text-output" title="Permalink to this headline">¶</a></h2>
<div class="section" id="unit-symbol">
<h3>Unit Symbol<a class="headerlink" href="#unit-symbol" title="Permalink to this headline">¶</a></h3>
<p>The library tries its best to print a correct unit of the quantity. This is why it performs
a series of checks:</p>
<ol class="simple">
<li><p>If the user predefined a unit with a <code class="docutils literal notranslate"><span class="pre">named_XXX_unit</span></code> class templates, the symbol provided
by the user will be used (i.e. <code class="docutils literal notranslate"><span class="pre">60</span> <span class="pre">W</span></code>).</p></li>
<li><p>If a unit was created with a <code class="docutils literal notranslate"><span class="pre">deduced_unit</span></code> class template, the symbol of deduced unit is
printed (i.e. <code class="docutils literal notranslate"><span class="pre">70</span> <span class="pre">km/h</span></code>).</p></li>
<li><p>Otherwise, the library tries to print a prefix and symbol of an unknown unit for this derived
dimension:</p></li>
</ol>
<ul class="simple">
<li><p>prefix:</p>
<ul>
<li><p>if ratio of the scaled unit is <code class="docutils literal notranslate"><span class="pre">1</span></code>, than no prefix is being printed,</p></li>
<li><p>otherwise, if <code class="docutils literal notranslate"><span class="pre">PrefixType</span></code> template parameter of a reference unit is different than
<code class="docutils literal notranslate"><span class="pre">no_prefix</span></code>, and if the ratio of scaled unit matches the ratio of a prefix of a specified
type, than the symbol of this prefix will be used,</p></li>
<li><p>otherwise, non-standard ratio (i.e. <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">[60]Hz</span></code>) will be printed.</p></li>
</ul>
</li>
<li><p>symbol:</p>
<ul>
<li><p>if a reference unit has a user-predefined or deduced symbol, than this symbol it is being
printed,</p></li>
<li><p>otherwise, the symbol is constructed from names and exponents of base dimensions
(i.e. <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">m/kg^2</span></code>).</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="operator">
<h3><code class="docutils literal notranslate"><span class="pre">operator&lt;&lt;</span></code><a class="headerlink" href="#operator" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">quantity::operator&lt;&lt;()</span></code> provides only a basic support to print a quantity. It prints its count
and a symbol separated with one space character.</p>
</div>
<div class="section" id="text-formatting">
<h3>Text Formatting<a class="headerlink" href="#text-formatting" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">mp-units</span></code> supports new C++20 formatting facility (currently provided as a dependency on
<a class="reference external" href="https://github.com/fmtlib/fmt"><code class="docutils literal notranslate"><span class="pre">fmt</span></code></a> library). <code class="docutils literal notranslate"><span class="pre">parse()</span></code> member functions of
<code class="docutils literal notranslate"><span class="pre">fmt::formatter&lt;units::quantity&lt;Dimension,</span> <span class="pre">Unit,</span> <span class="pre">Rep&gt;,</span> <span class="pre">CharT&gt;</span></code> class template partial
specialization interprets the format specification as a <code class="docutils literal notranslate"><span class="pre">units-format-spec</span></code> according to the
following syntax:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>units-format-spec:
     fill-and-align[opt] sign[opt] width[opt] precision[opt] units-specs[opt]
units-specs:
     conversion-spec
     units-specs conversion-spec
     units-specs literal-char
literal-char:
     any character other than { or }
conversion-spec:
     % modifier[opt] type
modifier: one of
     E O
type: one of
     n q Q t %
</pre></div>
</div>
<p>The productions <code class="docutils literal notranslate"><span class="pre">fill-and-align</span></code>, <code class="docutils literal notranslate"><span class="pre">sign</span></code>, <code class="docutils literal notranslate"><span class="pre">width</span></code>, and <code class="docutils literal notranslate"><span class="pre">precision</span></code> are described in
<a class="reference external" href="https://wg21.link/format.string.std">Format string</a> chapter of the C++ standard. Giving a
<code class="docutils literal notranslate"><span class="pre">precision</span></code> specification in the <code class="docutils literal notranslate"><span class="pre">units-format-spec</span></code> is valid only for <code class="docutils literal notranslate"><span class="pre">units::quantity</span></code> types
where the representation type <code class="docutils literal notranslate"><span class="pre">Rep</span></code> is a floating-point type. For all other <code class="docutils literal notranslate"><span class="pre">Rep</span></code> types, an
exception of type <code class="docutils literal notranslate"><span class="pre">format_error</span></code> is thrown if the <code class="docutils literal notranslate"><span class="pre">units-format-spec</span></code> contains a precision
specification. An <code class="docutils literal notranslate"><span class="pre">format_error</span></code> is also thrown if <code class="docutils literal notranslate"><span class="pre">sign</span></code> is provided with a <code class="docutils literal notranslate"><span class="pre">conversion-spec</span></code>
to print quantity unit but not its value.</p>
<p>Each conversion specifier <code class="docutils literal notranslate"><span class="pre">conversion-spec</span></code> is replaced by appropriate characters as described
in the following table:</p>
<p>| Specifier | Replacement                                                   |
|:———:|—————————————————————|
|   <code class="docutils literal notranslate"><span class="pre">%n</span></code>    | A new-line character                                          |
|   <code class="docutils literal notranslate"><span class="pre">%q</span></code>    | The quantity’s unit symbol                                    |
|   <code class="docutils literal notranslate"><span class="pre">%Q</span></code>    | The quantity’s numeric value (as if extracted via <code class="docutils literal notranslate"><span class="pre">.count()</span></code>) |
|   <code class="docutils literal notranslate"><span class="pre">%t</span></code>    | A horizontal-tab character                                    |
|   <code class="docutils literal notranslate"><span class="pre">%%</span></code>    | A <code class="docutils literal notranslate"><span class="pre">%</span></code> character                                               |</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">units-specs</span></code> is omitted, the <code class="docutils literal notranslate"><span class="pre">quantity</span></code> object is formatted as if by streaming it to
<code class="docutils literal notranslate"><span class="pre">std::ostringstream</span> <span class="pre">os</span></code> and copying <code class="docutils literal notranslate"><span class="pre">os.str()</span></code> through the output iterator of the context with
additional padding and adjustments as specified by the format specifiers.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">&quot;{:=&gt;12}&quot;</span><span class="p">,</span> <span class="mi">120</span><span class="n">q_km_per_h</span><span class="p">);</span> <span class="c1">// value of s is &quot;====120 km/h&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="improving-user-s-experience">
<h2>Improving user’s experience<a class="headerlink" href="#improving-user-s-experience" title="Permalink to this headline">¶</a></h2>
<p>Most of the important design decisions in the library are dictated by the requirement of
providing the best user experience as possible.</p>
<p>Most of C++ libraries in the world use template aliases to provide a friendly name for a
developer. Unfortunately, such aliases are quickly lost in a compilation process and as a
result the potential error log contains a huge source type rather than a short alias for it.
The same can be observed during debugging of a code using template aliases.</p>
<p>Let’s assume that we want to provide a user friendly name for a capacitance derived dimension.
Other libraries will do it in the following way:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">dim_capacitance</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">derived_dimension_base</span><span class="o">&lt;</span><span class="n">exp</span><span class="o">&lt;</span><span class="n">si</span><span class="o">::</span><span class="n">dim_electric_current</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span>
                                                       <span class="n">exp</span><span class="o">&lt;</span><span class="n">si</span><span class="o">::</span><span class="n">dim_length</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span>
                                                       <span class="n">exp</span><span class="o">&lt;</span><span class="n">si</span><span class="o">::</span><span class="n">dim_mass</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span>
                                                       <span class="n">exp</span><span class="o">&lt;</span><span class="n">si</span><span class="o">::</span><span class="n">dim_time</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>The above solution does provide a good developer’s experience but a really poor one for the end
user. If we will get a compilation error message containing <code class="docutils literal notranslate"><span class="pre">dim_capacitance</span></code> in most cases
the compiler will print the following type instead of the alias:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>units::detail::derived_dimension_base&lt;units::exp&lt;units::si::dim_electric_current, 2, 1&gt;,
units::exp&lt;units::si::dim_length, -2, 1&gt;, units::exp&lt;units::si::dim_mass, -1, 1&gt;,
units::exp&lt;units::si::dim_time, 4, 1&gt; &gt;
</pre></div>
</div>
<p>You can notice that even this long syntax was carefully selected to provide quite good user
experience (some other units libraries produce a type that cannot easily fit on one slide)
but it is not questionable less readable than just <code class="docutils literal notranslate"><span class="pre">dim_capacitance</span></code>.</p>
<p>NOTE: To better understand how the framework works and not clutter the text and graphs with
long types in the following examples we will switch from <code class="docutils literal notranslate"><span class="pre">dim_capacitance</span></code> to <code class="docutils literal notranslate"><span class="pre">dim_area</span></code>.
The latter one has much shorter definition but the end result for both will be exactly the same.
User-friendly, short name printed by the compiler and the debugger.</p>
<p>To fix it we have to provide a strong type. As we do not have opaque/strong typedefs
in the language we have to use inheritance:</p>
<p><img alt="UML" src="_images/downcast_1.png" /></p>
<p>This gives us a nice looking strong type but does not solve the problem of how to switch from
a long instantiation of a <code class="docutils literal notranslate"><span class="pre">derived_dimension_base</span></code> class template that was generated by the
framework as a result of dimensional calculation to a child class assigned by the user for this
instantiation.</p>
<div class="section" id="downcasting-facility">
<h3>Downcasting facility<a class="headerlink" href="#downcasting-facility" title="Permalink to this headline">¶</a></h3>
<p>To support this <code class="docutils literal notranslate"><span class="pre">mp-units</span></code> library introduces a new downcasting facility implemented fully as
a library feature. It creates 1-to-1 link between a long class template instantiation and a
strong type provided by the user. This means that only one child class can be created for a
specific base class template instantiation.</p>
<p>Downcasting facility is provided by injecting two classes into our hierarchy:</p>
<p><img alt="UML" src="_images/downcast_2.png" /></p>
<p>In the above example <code class="docutils literal notranslate"><span class="pre">dim_area</span></code> is a downcasting target (child class) and a specific
<code class="docutils literal notranslate"><span class="pre">detail::derived_dimension</span></code> class template instantiation is a downcasting source (base class).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">BaseType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">downcast_base</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">downcast_base_type</span> <span class="o">=</span> <span class="n">BaseType</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">auto</span> <span class="nf">downcast_guide</span><span class="p">(</span><span class="n">downcast_base</span><span class="p">);</span>  <span class="c1">// declaration only (no implementation)</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">units::downcast_base</span></code> is a class that implements CRTP idiom, marks the base of downcasting
facility with a <code class="docutils literal notranslate"><span class="pre">downcast_base_type</span></code> member type, and provides a declaration of downcasting ADL
friendly (Hidden Friend) entry point member function <code class="docutils literal notranslate"><span class="pre">downcast_guide</span></code>. An important design point
is that this function does not return any specific type in its declaration. This non-member
function is going to be defined in a child class template <code class="docutils literal notranslate"><span class="pre">downcast_child</span></code> and will return a
target type of the downcasting operation there.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">Downcastable</span> <span class="o">=</span>
    <span class="k">requires</span> <span class="p">{</span>
      <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">downcast_base_type</span><span class="p">;</span>
    <span class="p">}</span> <span class="o">&amp;&amp;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">derived_from</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">downcast_base</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">downcast_base_type</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">units::Downcastable</span></code> is a concepts that verifies if a type implements and can be used in a
downcasting facility.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Target</span><span class="p">,</span> <span class="n">Downcastable</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">downcast_child</span> <span class="p">:</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="k">auto</span> <span class="n">downcast_guide</span><span class="p">(</span><span class="k">typename</span> <span class="n">downcast_child</span><span class="o">::</span><span class="n">downcast_base</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Target</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">units::downcast_child</span></code> is another CRTP class template that provides the implementation of a
non-member friend function of the <code class="docutils literal notranslate"><span class="pre">downcast_base</span></code> class template which defines the target
type of a downcasting operation.</p>
<p>With such CRTP types the only thing the user has to do to register a new type to the downcasting
facility is to publicly derive from one of those CRTP types and provide its new child type as
the first template parameter of the CRTP type.</p>
<p>Above types are used to define base and target of a downcasting operation. To perform the actual
downcasting operation a dedicated template alias is provided:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">Downcastable</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">downcast</span> <span class="o">=</span> <span class="k">decltype</span><span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">downcast_target_impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">units::downcast</span></code> is used to obtain the target type of the downcasting operation registered
for a given instantiation in a base type. <code class="docutils literal notranslate"><span class="pre">detail::downcast_target_impl</span></code> checks if a downcasting
target is registered for the specific base class. If yes, it returns the registered type,
otherwise it works like a regular identity type returning a provided base class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">concept</span> <span class="n">has_downcast</span> <span class="o">=</span> <span class="k">requires</span> <span class="p">{</span>
    <span class="n">downcast_guide</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">downcast_base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">());</span>
  <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">downcast_target_impl</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span><span class="n">has_downcast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
      <span class="k">return</span> <span class="k">decltype</span><span class="p">(</span><span class="n">downcast_guide</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">downcast_base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">()))();</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="nf">T</span><span class="p">();</span>
  <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>Additionally there is one more simple helper alias provided that is used in the internal
library implementation:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">Downcastable</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">downcast_base_t</span> <span class="o">=</span> <span class="n">T</span><span class="o">::</span><span class="n">downcast_base_type</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="unknown-dimension-exponent">
<h3><code class="docutils literal notranslate"><span class="pre">unknown_dimension&lt;Exponent...&gt;</span></code><a class="headerlink" href="#unknown-dimension-exponent" title="Permalink to this headline">¶</a></h3>
<p>Sometimes dimensional calculation results with a class template instantiation that was not
predefined by the user in the downcasting facility. A typical example of such a case are
temporary results of calculations:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">units</span><span class="o">::</span><span class="n">Length</span> <span class="k">auto</span> <span class="n">d1</span> <span class="o">=</span> <span class="mi">123</span><span class="n">q_m</span><span class="p">;</span>
<span class="n">units</span><span class="o">::</span><span class="n">Time</span> <span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="mi">10</span><span class="n">q_s</span><span class="p">;</span>
<span class="n">units</span><span class="o">::</span><span class="n">Velocity</span> <span class="k">auto</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">avg_speed</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">*</span> <span class="mi">50</span><span class="n">q_m</span><span class="p">;</span>  <span class="c1">// intermediate unknown dimension</span>

<span class="n">units</span><span class="o">::</span><span class="n">Velocity</span> <span class="k">auto</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">temp1</span> <span class="o">/</span> <span class="mi">100</span><span class="n">q_m</span><span class="p">;</span> <span class="c1">// back to known dimensions again</span>
<span class="n">units</span><span class="o">::</span><span class="n">Length</span> <span class="k">auto</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">*</span> <span class="mi">60</span><span class="n">q_s</span><span class="p">;</span>
</pre></div>
</div>
<p>To provide support to form an unknown derived dimension that could be than be converted to a
known one with a correct unit, and also to improve the user experience and clearly state that
it is an unknown dimension the library framework will provide an instance of:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nl">unknown_coherent_unit</span> <span class="p">:</span> <span class="n">unit</span><span class="o">&lt;</span><span class="n">unknown_coherent_unit</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">Exponent</span> <span class="n">E</span><span class="p">,</span> <span class="n">Exponent</span><span class="p">...</span> <span class="n">ERest</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">unknown_dimension</span> <span class="p">:</span> <span class="n">derived_dimension</span><span class="o">&lt;</span><span class="n">unknown_dimension</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">ERest</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
                                             <span class="n">scaled_unit</span><span class="o">&lt;</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">unknown_coherent_unit</span><span class="o">&gt;</span><span class="p">,</span>
                                             <span class="n">E</span><span class="p">,</span> <span class="n">ERest</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">coherent_unit</span> <span class="o">=</span> <span class="n">scaled_unit</span><span class="o">&lt;</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">unknown_coherent_unit</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>with this the error log or a debugger breakpoint involving a <code class="docutils literal notranslate"><span class="pre">temp1</span></code> type will include:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>units::quantity&lt;units::unknown_dimension&lt;units::exp&lt;units::si::dim_length, 2, 1&gt;,
units::exp&lt;units::si::dim_time, -1, 1&gt; &gt;, units::unknown_coherent_unit, long int&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="extensibility">
<h2>Extensibility<a class="headerlink" href="#extensibility" title="Permalink to this headline">¶</a></h2>
<p>The library was designed with a simple extensibility in mind. It is easy to add new units,
dimensions, and prefixes. The systems of units are not closed (classes) but open (namespaces)
and can be easily extended, or its content can be partially/fully imported to other systems.</p>
<div class="section" id="adding-a-new-system-with-custom-dimensions-and-units">
<h3>Adding a new system with custom dimensions and units<a class="headerlink" href="#adding-a-new-system-with-custom-dimensions-and-units" title="Permalink to this headline">¶</a></h3>
<p>A great example of a adding a whole new system can be a <code class="docutils literal notranslate"><span class="pre">data</span></code> system in the library which
adds support for digital information quantities. In summary it adds:</p>
<ol>
<li><p>New prefix type and its prefixes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">units</span><span class="o">::</span><span class="n">data</span> <span class="p">{</span>

<span class="k">struct</span> <span class="nl">prefix</span> <span class="p">:</span> <span class="n">prefix_type</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nl">kibi</span> <span class="p">:</span> <span class="n">units</span><span class="o">::</span><span class="n">prefix</span><span class="o">&lt;</span><span class="n">kibi</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="s">&quot;Ki&quot;</span><span class="p">,</span> <span class="n">ratio</span><span class="o">&lt;</span>    <span class="mi">1&#39;024</span><span class="o">&gt;&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">mebi</span> <span class="p">:</span> <span class="n">units</span><span class="o">::</span><span class="n">prefix</span><span class="o">&lt;</span><span class="n">mebi</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="s">&quot;Mi&quot;</span><span class="p">,</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1&#39;048&#39;576</span><span class="o">&gt;&gt;</span> <span class="p">{};</span>

<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>New units for <code class="docutils literal notranslate"><span class="pre">information</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">units</span><span class="o">::</span><span class="n">data</span> <span class="p">{</span>

<span class="k">struct</span> <span class="nl">bit</span> <span class="p">:</span> <span class="n">named_unit</span><span class="o">&lt;</span><span class="n">bit</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">kibibit</span> <span class="p">:</span> <span class="n">prefixed_unit</span><span class="o">&lt;</span><span class="n">kibibit</span><span class="p">,</span> <span class="n">kibi</span><span class="p">,</span> <span class="n">bit</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nl">byte</span> <span class="p">:</span> <span class="n">named_scaled_unit</span><span class="o">&lt;</span><span class="n">byte</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">bit</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">kibibyte</span> <span class="p">:</span> <span class="n">prefixed_unit</span><span class="o">&lt;</span><span class="n">kibibyte</span><span class="p">,</span> <span class="n">kibi</span><span class="p">,</span> <span class="n">byte</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>New base dimension, its concept, and quantity alias:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">units</span><span class="o">::</span><span class="n">data</span> <span class="p">{</span>

<span class="k">struct</span> <span class="nl">dim_information</span> <span class="p">:</span> <span class="n">base_dimension</span><span class="o">&lt;</span><span class="s">&quot;information&quot;</span><span class="p">,</span> <span class="n">bit</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">Information</span> <span class="o">=</span> <span class="n">QuantityOf</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">dim_information</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">Unit</span> <span class="n">U</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">Rep</span> <span class="o">=</span> <span class="kt">double</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">information</span> <span class="o">=</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">dim_information</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Rep</span><span class="o">&gt;</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>UDLs for new units</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">units</span><span class="o">::</span><span class="n">data</span><span class="o">::</span><span class="kr">inline</span> <span class="n">literals</span> <span class="p">{</span>

<span class="c1">// bits</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">q_b</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">information</span><span class="o">&lt;</span><span class="n">bit</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="p">}</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">q_Kib</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">information</span><span class="o">&lt;</span><span class="n">kibibit</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// bytes</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">q_B</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">information</span><span class="o">&lt;</span><span class="n">byte</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="p">}</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">q_KiB</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">information</span><span class="o">&lt;</span><span class="n">kibibyte</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>A new <code class="docutils literal notranslate"><span class="pre">bitrate</span></code> derived dimension, its units, concept, quantity helper, and UDLs</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">units</span><span class="o">::</span><span class="n">data</span> <span class="p">{</span>

<span class="k">struct</span> <span class="nl">bit_per_second</span> <span class="p">:</span> <span class="n">unit</span><span class="o">&lt;</span><span class="n">bit_per_second</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">dim_bitrate</span> <span class="p">:</span> <span class="n">derived_dimension</span><span class="o">&lt;</span><span class="n">dim_bitrate</span><span class="p">,</span> <span class="n">bit_per_second</span><span class="p">,</span> <span class="n">exp</span><span class="o">&lt;</span><span class="n">dim_information</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">exp</span><span class="o">&lt;</span><span class="n">si</span><span class="o">::</span><span class="n">dim_time</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">&gt;&gt;</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nl">kibibit_per_second</span> <span class="p">:</span> <span class="n">deduced_unit</span><span class="o">&lt;</span><span class="n">kibibit_per_second</span><span class="p">,</span> <span class="n">dim_bitrate</span><span class="p">,</span> <span class="n">kibibit</span><span class="p">,</span> <span class="n">si</span><span class="o">::</span><span class="n">second</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">Bitrate</span> <span class="o">=</span> <span class="n">QuantityOf</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">dim_bitrate</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">Unit</span> <span class="n">U</span><span class="p">,</span> <span class="n">Scalar</span> <span class="n">Rep</span> <span class="o">=</span> <span class="kt">double</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">bitrate</span> <span class="o">=</span> <span class="n">quantity</span><span class="o">&lt;</span><span class="n">dim_bitrate</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Rep</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">inline</span> <span class="k">namespace</span> <span class="n">literals</span> <span class="p">{</span>

<span class="c1">// bits</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">q_b_per_s</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bitrate</span><span class="o">&lt;</span><span class="n">bit_per_second</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="p">}</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">q_Kib_per_s</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bitrate</span><span class="o">&lt;</span><span class="n">kibibit_per_second</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="p">}</span>

<span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="using-custom-representations">
<h3>Using custom representations<a class="headerlink" href="#using-custom-representations" title="Permalink to this headline">¶</a></h3>
<p>In theory <code class="docutils literal notranslate"><span class="pre">quantity</span></code> can take any arithmetic-like type as a <code class="docutils literal notranslate"><span class="pre">Rep</span></code> template parameter. In
practice some interface is forced by numeric concepts.</p>
<p>To provide basic library functionality the type should satisfy the <code class="docutils literal notranslate"><span class="pre">Scalar</span></code> concept:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">basic</span><span class="o">-</span><span class="n">arithmetic</span> <span class="o">=</span> <span class="c1">// exposition only</span>
  <span class="n">std</span><span class="o">::</span><span class="n">magma</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">plus</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">magma</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">minus</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">magma</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">times</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">magma</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">divided_by</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">Scalar</span> <span class="o">=</span>
  <span class="p">(</span><span class="o">!</span><span class="n">Quantity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
  <span class="p">(</span><span class="o">!</span><span class="n">WrappedQuantity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">regular</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">totally_ordered</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
  <span class="n">basic</span><span class="o">-</span><span class="n">arithmetic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">WrappedQuantity</span></code> is a concept that applies <code class="docutils literal notranslate"><span class="pre">Quantity&lt;typename</span> <span class="pre">T::value_type&gt;</span></code> recursively
on all nested types to check if <code class="docutils literal notranslate"><span class="pre">T</span></code> is not actually a wrapped quantity type (i.e. a vector or
matrix of quantities).</p>
<p>The above implies that the <code class="docutils literal notranslate"><span class="pre">Rep</span></code> type should provide at least:</p>
<ul class="simple">
<li><p>default constructor, destructor, copy-constructor, and copy-assignment operator</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator==(Rep,</span> <span class="pre">Rep)</span></code>, <code class="docutils literal notranslate"><span class="pre">operator!=(Rep,</span> <span class="pre">Rep)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator&lt;(Rep,</span> <span class="pre">Rep)</span></code>, <code class="docutils literal notranslate"><span class="pre">operator&gt;(Rep,</span> <span class="pre">Rep)</span></code>, <code class="docutils literal notranslate"><span class="pre">operator&lt;=(Rep,</span> <span class="pre">Rep)</span></code>, <code class="docutils literal notranslate"><span class="pre">operator&gt;=(Rep,</span> <span class="pre">Rep)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator-(Rep)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator+(Rep,</span> <span class="pre">Rep)</span></code>, <code class="docutils literal notranslate"><span class="pre">operator-(Rep,</span> <span class="pre">Rep)</span></code>, <code class="docutils literal notranslate"><span class="pre">operator*(Rep,</span> <span class="pre">Rep)</span></code>, <code class="docutils literal notranslate"><span class="pre">operator*(Rep,</span> <span class="pre">Rep)</span></code></p></li>
</ul>
<p>Above also requires that the <code class="docutils literal notranslate"><span class="pre">Rep</span></code> should be implicitly convertible from integral types
(i.e. <code class="docutils literal notranslate"><span class="pre">int</span></code>) so a proper implicit converting constructor should be provided.</p>
<p>Moreover, in most cases to observe expected behavior <code class="docutils literal notranslate"><span class="pre">Rep</span></code> will have to be registered as a
floating-point representation type by specializing <code class="docutils literal notranslate"><span class="pre">units::treat_as_floating_point</span></code> type
trait:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Rep</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">treat_as_floating_point</span><span class="p">;</span>
</pre></div>
</div>
<p>An example of such a type can be found in <a class="reference external" href="../example/measurement.cpp">measurement example</a>.</p>
<p>However, as written above this will enable only a basic functionality of the library. In case
additional <code class="docutils literal notranslate"><span class="pre">quantity</span></code> operations are needed the user may opt-in to any of them by providing
the equivalent operation for <code class="docutils literal notranslate"><span class="pre">Rep</span></code> type. Here is an additional list of opt-in operations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">operator++()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator++(int)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator--()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator--(int)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator+=(Rep)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator-=(Rep)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator*=(Rep)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator/=(Rep)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator%=(Rep)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operator%(Rep,</span> <span class="pre">Rep)</span></code></p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">quantity</span></code> also has 4 static  functions <code class="docutils literal notranslate"><span class="pre">zero()</span></code>, <code class="docutils literal notranslate"><span class="pre">one()</span></code>, <code class="docutils literal notranslate"><span class="pre">min()</span></code>, and <code class="docutils literal notranslate"><span class="pre">max()</span></code> which can
be enabled by providing a specialization of <code class="docutils literal notranslate"><span class="pre">quantity_values</span></code> type trait for <code class="docutils literal notranslate"><span class="pre">Rep</span></code> type:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">Scalar</span> <span class="n">Rep</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">quantity_values</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="faq">
<h2>FAQ<a class="headerlink" href="#faq" title="Permalink to this headline">¶</a></h2>
<ol>
<li><p>Why all UDLs are prefixed with <code class="docutils literal notranslate"><span class="pre">q_</span></code> instead of just using unit symbol?</p>
<p>Usage of only unit symbols in UDLs would be a preferred approach (less to type, easier to
understand and maintain). However, while increasing the coverage for the library we learned
that there are a lot unit symbols that conflict with built-in types or numeric extensions.
A few of those are: <code class="docutils literal notranslate"><span class="pre">F</span></code> (farad), <code class="docutils literal notranslate"><span class="pre">J</span></code> (joule), <code class="docutils literal notranslate"><span class="pre">W</span></code> (watt), <code class="docutils literal notranslate"><span class="pre">K</span></code> (kelvin), <code class="docutils literal notranslate"><span class="pre">d</span></code> (day), <code class="docutils literal notranslate"><span class="pre">l</span></code> or
<code class="docutils literal notranslate"><span class="pre">L</span></code> (litre), <code class="docutils literal notranslate"><span class="pre">erg</span></code>, <code class="docutils literal notranslate"><span class="pre">ergps</span></code>. For a while we had to used <code class="docutils literal notranslate"><span class="pre">_</span></code> prefix to make the library work
at all but at some point we had to unify the naming and we came up with <code class="docutils literal notranslate"><span class="pre">q_</span></code> prefix which
results in a creation of quantity of a provided unit.</p>
</li>
<li><p>Why dimensions depend on units and not vice versa?</p>
<p>Most of the libraries define units in terms of dimensions and this was also an initial
approach for this library. However it turns out that for such a design it is hard to provide
support for all the required scenarios.</p>
<p>The first of them is to support multiple unit systems (like SI, CGS, …) where each of
can have a different base unit for the same dimension. Base quantity of dimension length in
SI has to know that it should use <code class="docutils literal notranslate"><span class="pre">m</span></code> to print the unit symbol to the text output, while
the same dimension for CGS should use <code class="docutils literal notranslate"><span class="pre">cm</span></code>. Also it helps in conversions among those systems.</p>
<p>The second one is to support natural units where more than one dimension can be measured
with the same unit (i.e. <code class="docutils literal notranslate"><span class="pre">GeV</span></code>). Also if someone will decide to implement a systems where
SI quantities of the same kind are expressed as different dimensions (i.e. height, width,
and depth) all of them will just be measured in meters.</p>
</li>
<li><p>Why do we spell <code class="docutils literal notranslate"><span class="pre">metre</span></code> instead of <code class="docutils literal notranslate"><span class="pre">meter</span></code>?</p></li>
</ol>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018-present, Mateusz Pusz

    </p>
  </div>
    
    
      Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>